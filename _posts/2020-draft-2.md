---
title: Evading Code Injection Attacks on Linux Applications
---

__Code injection__ attacks, such as DLL/dependency hijacking or hotpatching, have become commonplace for attackers wanting to escalate privileges or mutate an application's runtime (ie bypassing a license check) by loading their own crafted code in-memory to pre-existing applications.

Since this has become a known attack vector, OS vendors have already jumped ahead and implemented many facilities to help mitigate against such attacks. Windows' sophisticated Threat Protection software

macOS introduced both the `__RESTRICT` program header and entitlements.

However, with Linux, the protections against code injection is pretty lackluster. With `LD_PRELOAD`

But I argue instead of re-inventing the wheel with how our dynamic linkers and kernel-level protections work, let's take a look at a portable technique I devised that allows apps to _protect themselves_, by statically patching apps to run our lighweight protection runtime _before_ executing actual code. This is known as _runtime application self-protection_.

So let's talk about beating code injection for Linux apps - by using code injection.

Attempts to `LD_PRELOAD` our malicious shared object to our application now cease to work, as

Embedding code to these sections in the ELF binary is a double-edged sword - we are adding a layer of protection, but weare also blocking (may not completely preventing) attackers from hotpatching these sections themselves with their own malicious code. You can think of this as us leveraging this first for defense, before the attackers get to use it for their offense.

## Tamper-proof?

The technically proficient reader may ask, "can't a sophisticated enough attacker who understands the intrinsics of this technique simply beat it by patching out the protection runtime itself?"

Yes, absolutely! Since the protection runtime is embedded with the application itself, there's no reason why an experienced attacker won't simply be able _rewrite_ our earlier work themselves.

This is where `ward`'s binary signing and validation feature comes in. This is something, again, built-in on both Windows (Authenticode) and macOS (`code-sign`), but not on Linux without baking in security-enhanced features (ie. grsecurity) into the kernel itself.
